# Engine-Fire (BBS 분석)

## 목차

1. esframework
2. api 예하 폴더 골격
3. ElasticSearch / OpenSearch
4. A-RMS에서 ES 활용 방안

## 1. esframework

```shell
egoveframework.javaservice.esframework
├─annotation  # 커스텀 어노테이션을 모아둔 폴더 (주 로직은 ReflectionUtil.java)
│      ElasticSearchCreatedDate.java      # 생성일 필드변수용
│      ElasticSearchIndex.java            # 마커 어노테이션
│      ElasticSearchTemplateConfig.java   # 마커 어노테이션
│      ElasticSearchUpdateDate.java       # 수정일 필드변수용
│      IndexStatusSnapShot.java           # ALM 색인 작업 전후 스냅샷 용도(추측)
│      Recent.java                        # EntityClass의 필드변수용 마커 어노테이션
│      RecentId.java                      # EsCommonRepositoryImpl.findRecentDocByRecentId() / EntityClass의 필드변수용 마커 어노테이션
│      RollingIndexName.java              # 인덱스 별칭용 (es 관련)
│
├─config  # 설정파일
│      EsIndexTemplateConfig.java         # 실행 시 생성되는 Es 색인 템플릿 설정. @ElasticSearchTemplateConfig 검색 후 @RollingIndexName에 따라 index pattern 설정
│      RepositoryConfiguration.java       # Repository 제한 설정. @EnableElasticsearchRepositories 스캔 후 basePackages 하위 클래스에서 EsCommonRepository 필드를 갖고있는 클래스 스캔 후 getModifiers, getDeclaredMethods를 통해 EsCommonRepository 관련하여 통제
│
├─esquery
│  │  EsQuery.java      # es 쿼리 빌더의 기본 구조를 추상화한 클래스
│  │  SimpleQuery.java  # EsQuery를 extends하고 있으며 빌더용 객체
│  │
│  ├─bool
│  │      EsBoolQuery.java  # SimpleQuery.toSearchDoc()에서 사용되며 extends하고 있는 EsQuery에서의 boolQueryBuilder 설정 추상화용 (파악 필요)
│  │
│  ├─filter # 검색 점수 반영 X
│  │      ExistsQueryFilter.java    # 필드명 존재여부 필터 (extends ExistsQueryBuilder)
│  │      Filter.java               # 필터 공통화(팩토리 메서드?)
│  │      MatchQueryFilter.java     # 분석기 적용된 유사 검색 (extends MatchQueryBuilder)
│  │      QueryStringFilter.java    # 받은 변수를 분석기를 통해 분할 후 Operator로 결과 필터
│  │      RangeQueryFilter.java     # 숫자/날짜/점수(score) 필터 (extends RangeQueryBuilder)
│  │      TermQueryFilter.java      # 완벽하게 일치 검색 (extends TermQueryBuilder)
│  │      TermsQueryFilter.java     # 완벽 일치 검색, value를 리스트로 넘길 때 사용
│  │      WildCardQueryFilter.java  # 와일드카드 검색용이며 '*' 보내거나 null을 보낼 시 필터 적용 X
│  │
│  ├─highlight
│  │      EsHighlightQuery.java     # 문서 검색 후 반환되는 해당 필드의 값 값 앞뒤에 em 태그 적용
│  │
│  ├─must # 반드시 만족 / 검색 점수 반영 O
│  │      MatchAllQueryMust.java    # 모든 문서 검색용
│  │      Must.java                 # Must 공통화
│  │      QueryStringMust.java      # 받은 변수를 분석기를 통해 분할 후 검색에 적용 (?)
│  │      TermQueryMust.java        # 완벽하게 일치
│  │
│  ├─mustnot  # 검색 점수 반영 X
│  │      ExistsQueryMustNot.java   # 해당 필드명이 존재하지 않는 문서 검색
│  │      MustNot.java              # MustNot 공통화
│  │      TermQueryMustNot.java     # 완벽하게 불일치 검색 (!=)
│  │      TermsQueryMustNot.java    # 완벽 불일치 검색, value를 리스트로 넘길 때 사용
│  │
│  └─sort
│          EsSortQuery.java         # 검색된 문서 정렬
│
├─factory
│  │  AggregationQueryFactory.java  # (집계용 팩토리 / ?)
│  │  SearchDocQueryFactory.java    # (문서 팩토리 / ?)
│  │
│  ├─builder
│  │      AbstractQueryBuilder.java
│  │      AggregationQuery.java 
│  │      AggregationQueryBuilder.java
│  │      SearchQueryBuilder.java
│  │
│  └─creator
│          AggregationQueryCreator.java
│          DateAggregationQueryCreator.java
│
├─model
│  ├─dto
│  │  ├─esquery # 검색 조건 또는 반환값 용
│  │  │      HighlightDTO.java          # EsHighlightQuery 적용 DTO
│  │  │      MainGroupDTO.java          # 집계용 (SubGroupFieldDTO)
│  │  │      SearchDocDTO.java          # 문서 검색 DTO
│  │  │      SingleValueGroupDTO.java   # 단일 집계용
│  │  │      SortDTO.java               # EsSortQuery 적용 DTO
│  │  │      SubGroupFieldDTO.java      # 집계용 하위 집계 (?)
│  │  │
│  │  └─request # 검색 요청용 DTO
│  │          AggregationCardinalityRequestDTO.java # (?)
│  │          AggregationRequestDTO.java            # 집계 검색 요청용
│  │          SearchRequestDTO.java                 # 문서 검색 요청용
│  │
│  ├─entity
│  │      BaseEntity.java         # BaseEntity 인터페이스 (아무것도 없음)
│  │      IndexStatusEntity.java  # 색인 상태 확인용
│  │      JobStatus.java          # 색인 작업이 된건지 아닌건지 구별용 enum
│  │
│  └─vo
│          CatIndexVO.java              # Index VO
│          DocumentAggregations.java    # 문서 집계
│          DocumentBucket.java          # (?)
│          DocumentResultWrapper.java   # 문서 결과
│          SearchDocResult.java         # 문서 결과 인터페이스 (아무것도 없음)
│          UpperLevel.java              # (?)
│
├─repository
│  ├─common
│  │      EsCommonRepository.java                     # Repository 인터페이스 (extends SimpleElasticsearchWrapperRepository)
│  │      EsCommonRepositoryImpl.java                 # EsCommonRepository 구현체
│  │      EsCommonRepositoryWrapper.java              # EsCommonRepositoryImpl와 미리 지정된 EntityClass을 다형성으로 묶는 Wrapper
│  │      FindRepository.java                         # EntityClass가 Bean에 등록되어있는지 확인
│  │      IndexStatusSaveAspect.java
│  │      RecentFieldConvertor.java
│  │      SimpleElasticsearchWrapperRepository.java
│  │
│  └─indexstatus
│          IndexStatusRepository.java
│
└─util
        ReflectionUtil.java
```

## 2. api 예하 폴더 골격

1. 기본적인 Controller/Service/Repository로 구성 (실질적으로 여기에 있는 Repository 사용 X)
2. Controller는 기본적인 Controller의 역할만 하고있으며 로직은 Service에서 구현
3. Service에서는 EntityClassConfig에 미리 등록된 경우에만 EsCommonRepositoryWrapper를 사용 가능
4. model 패키지 내부에는 constant/dto/entity/vo로 구성됨

## 3. ElasticSearch / OpenSearch

ElasticSearch는 Apache Lucene을 기반으로 만들어진 검색 엔진입니다.
Apache Lucene의 flush 과정은 아래와 같습니다. (flush: Memory Buffer를 비우는 것)
1. 문서 index 요청이 들어올 시 역색인(inverted index)를 생성
2. 역색인 정보는 메모리 버퍼에 임시로 저장되며, 후에 디스크로 이동 시 `segment`라는 인덱스 파일 생성
3. 2번에서 생성된 `segment`는 page cache에 저장되어 최소한의 자원으로 데이터 검색 가능

##### 역색인(inverted index)란?
    문서를 검색 가능한 데이터로 만들기 위한 작업. 단어 중심으로 문서 위치 정보와 저장.

### ElasticSearch의 핵심 용어
- Document: ElasticSearch에서 저장되는 데이터의 기본 단위. (Row 또는 레코드와 유사)
- Field: Document 구성하기 위한 속성
- Aggregation: 집계 추출용 (GROUP BY와 유사)
- Index: 공통적 특징을 가진 Document들의 컬렉션. (테이블과 유사)
- Shard: Index를 수평 분할한 단위 (raid 0와 유사)
- Analyzer: 분석기를 통해 FieldType이 keyword가 아닌 것은 단어를 설정된 길이만큼 나누기

## 4. 결론: A-RMS에서 ES 활용 방안

1. 대규모 데이터 생성/조회 처리를 위함. A-RMS 프로젝트 중 ES가 적용되어있는 프로젝트는 Engine-Fire이다. A-RMS에서 필요한 것은 대규모 ALM 데이터 빠른 시간내에 저장하고 조회가 가능해야한다.
2. ElasticSearch를 통해 ALM의 대규모 데이터에 대한 집계 용도.
3. 검색 엔진으로써의 역할. RDBMS에서는 `like`를 통해 포함한 데이터를 찾을 수 있지만 유사한 데이터는 검색할 수 없습니다. 그러나 ElasticSearch는 검색 엔진으로서 포함한 데이터뿐만 아니라 분석기를 통해 단어를 분할하며 분할된 데이터를 통해 유사한 정보도 찾을 수 있습니다.
